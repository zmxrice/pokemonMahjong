<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Crushing</title>
</head>
  <script src="pixijs/pixi.min.js"></script>
<body>
  <script type="text/javascript">
    var CANVAS_WIDTH = 1200;
    var CANVAS_HEIGHT = 650;
    var LEFT_MARGIN = 100;
    var TOP_MARGIN = 30;
    var GRID_WIDTH = 50;
    var GRID_HEIGHT = 65;
    // leave 4 edges blank without pokemons
    var GRID_ROW_COUNT = CANVAS_HEIGHT / GRID_HEIGHT;
    var GRID_COL_COUNT = CANVAS_WIDTH / GRID_WIDTH;
    var SPECIES_OF_POKEMON = 30;

    var app = new PIXI.Application(window.innerWidth, window.innerHeight, { transparent: true });
    document.body.appendChild(app.view);

    var grid_matrix;

    var source_idx = Math.floor(Math.random() * 5);

    PIXI.loader
      .add("tilesets/pokemons_"+source_idx+".json")
      .load(setup);

    function setup() {
      // get all the pokemons
      var pokemonTexture;
      var pokemon;
      var pokemons = [];
      for (var t in PIXI.utils.TextureCache){
        if (t.startsWith("300px")){
          pokemonTexture = PIXI.utils.TextureCache[t];
          pokemons.push(pokemonTexture);
        }
      }

      var i = 0;
      var j = 0;
      var rand_idx;
      var is_second = false;
      // init matrix
      var pokemon_matrix = new Array(GRID_ROW_COUNT-2);
      for (i = 0; i < GRID_ROW_COUNT-2; i++) {
        pokemon_matrix[i] = new Array(GRID_COL_COUNT-2);
      }

      var pokemon_array = [];

      for (i = 0; i < GRID_ROW_COUNT-2; i++) {
        for (j = 0; j < GRID_COL_COUNT-2; j++) {
          if (!is_second) {
            rand_idx = Math.floor(Math.random() *
              Math.min(pokemons.length, SPECIES_OF_POKEMON
              )
            );
          }
          is_second = !is_second;
          pokemon = new PIXI.Sprite(pokemons[rand_idx]);
          pokemon_array.push(pokemon);
        }
      }

      // shuffle the matrix, change if a better way is found
      pokemon_array.sort(function() { return 0.5 - Math.random() });
      var cnt = 0;
      for (i = 0; i < GRID_ROW_COUNT-2; i++) {
        for (j = 0; j < GRID_COL_COUNT-2; j++) {
          pokemon_matrix[i][j] = pokemon_array[cnt];
          cnt ++;
        }
      }

      // init the grid system
      var grid_x = LEFT_MARGIN;
      var grid_y = TOP_MARGIN;
      var background = new PIXI.Graphics();
      background.beginFill(0xCCCCCC);
      background.lineStyle(2, 0xCCCCCC, 1);
      background.drawRect(LEFT_MARGIN, TOP_MARGIN, CANVAS_WIDTH, CANVAS_HEIGHT);
      background.endFill();

      // init matrix
      grid_matrix = new Array(GRID_ROW_COUNT);
      for (i = 0; i < GRID_ROW_COUNT; i++) {
        grid_matrix[i] = new Array(GRID_COL_COUNT);
      }

      for (i = 0; i < GRID_ROW_COUNT; i++) {
        for (j = 0; j < GRID_COL_COUNT; j++) {
          var grid = new PIXI.Graphics();

          if (i != 0 && i != GRID_ROW_COUNT-1
            && j != 0 && j != GRID_COL_COUNT - 1
          ){
            grid.buttonMode = true;
            grid.beginFill(0xFFFFFF);
            grid.lineStyle(2, 0xcbcfd6, 1);
            grid_x = LEFT_MARGIN + j * GRID_WIDTH;
            grid_y = TOP_MARGIN + i * GRID_HEIGHT;
            grid.drawRect(grid_x, grid_y, GRID_WIDTH, GRID_HEIGHT);
            grid.endFill();
            // the four edges are blank
            pokemon = pokemon_matrix[i-1][j-1];
            pokemon.scale.set(0.15);
            pokemon.x = grid_x + 2;
            pokemon.y = grid_y + 5;
            grid.addChild(pokemon);
            grid_matrix[i][j] = {
              "xcor": pokemon.x,
              "ycor": pokemon.y,
              "has_pokemon": true
            };
            grid.interactive = true;
            grid.buttonMode = true;
            grid.on('pointerdown', gridClick);
          } else {
            grid.beginFill(0xCCCCCC, 0);
            grid.lineStyle(2, 0xCCCCCC, 1);
            grid_x = LEFT_MARGIN + j * GRID_WIDTH;
            grid_y = TOP_MARGIN + i * GRID_HEIGHT;
            grid.drawRect(grid_x, grid_y, GRID_WIDTH, GRID_HEIGHT);
            grid.endFill();

            grid_matrix[i][j] = {
              "xcor": grid_x,
              "ycor": grid_y,
              "has_pokemon": false
            };
          }

          background.addChild(grid);
        }
      }

      app.stage.addChild(background);
    }

    var rectangle;
    var selected_pokemon;
    var selected_id;
    var selected_pos;
    var first_turn_grid;
    var second_turn_grid;

    function gridClick() {
      var cur_pos = findPos(
        this.children[0].x, this.children[0].y
      );
      if (selected_pokemon !== undefined
        && !(cur_pos[0] === selected_pos[0] && cur_pos[1] === selected_pos[1])
      ) {
        selected_pokemon.alpha = 1;
        if (selected_id === this.children[0].texture.textureCacheIds[0]
          && canBeErased(selected_pos, cur_pos)
        ) {
          var line = new PIXI.Graphics();
          var width_offset = Math.floor(GRID_WIDTH / 2);
          var height_offset = Math.floor(GRID_HEIGHT / 2);
          if (cur_pos[0] === selected_pos[0]
            && (cur_pos[0] === 1 || cur_pos[0] === GRID_ROW_COUNT-2)
          ){
            console.log("h edge");
            width_offset -= 2;
          }
          if (cur_pos[1] === selected_pos[1]
            && (cur_pos[1] === 1 || cur_pos[1] === GRID_COL_COUNT-2)
          ){
            console.log("v edge")
            height_offset -= 5;
          }

          console.log(cur_pos);
          console.log(selected_pos);

          line.lineStyle(4, 0x0a3d91, 1);
          line.moveTo(
            grid_matrix[selected_pos[0]][selected_pos[1]].xcor + width_offset,
            grid_matrix[selected_pos[0]][selected_pos[1]].ycor + height_offset
          );
          if (first_turn_grid !== undefined){
            line.lineTo(
              first_turn_grid.xcor + Math.floor(GRID_WIDTH / 2),
              first_turn_grid.ycor + Math.floor(GRID_HEIGHT / 2)
            );
          }
          if (second_turn_grid !== undefined){
            line.lineTo(
              second_turn_grid.xcor + Math.floor(GRID_WIDTH / 2),
              second_turn_grid.ycor + Math.floor(GRID_HEIGHT / 2)
            );
          }
          line.lineTo(
            grid_matrix[cur_pos[0]][cur_pos[1]].xcor + width_offset,
            grid_matrix[cur_pos[0]][cur_pos[1]].ycor + height_offset
          );

          console.log("--------------------------")
          if (first_turn_grid !== undefined){
            console.log(first_turn_grid.xcor + ", "+ first_turn_grid.ycor);
          }
          if (second_turn_grid !== undefined){
            console.log(second_turn_grid.xcor +", "+second_turn_grid.ycor);
          }

          console.log(grid_matrix[selected_pos[0]][selected_pos[1]].xcor
            +","+grid_matrix[selected_pos[0]][selected_pos[1]].ycor);
          console.log(grid_matrix[cur_pos[0]][cur_pos[1]].xcor
            +", "+grid_matrix[cur_pos[0]][cur_pos[1]].ycor);

          app.stage.addChild(line);

          var cur_grid = this;
          setTimeout(function(){
            grid_matrix[selected_pos[0]][selected_pos[1]].has_pokemon = false;
            grid_matrix[cur_pos[0]][cur_pos[1]].has_pokemon = false;
            selected_pokemon.parent.destroy();
            cur_grid.destroy();
            rectangle.destroy();
            rectangle = undefined;
            selected_id = undefined;
            selected_pokemon = undefined;
            selected_pos = undefined;
            first_turn_grid = undefined;
            second_turn_grid = undefined;
            line.destroy();
          }, 200);
          return;
        }
      }

      selected_pokemon = this.children[0];

      if (rectangle === undefined) {
        rectangle = new PIXI.Graphics();
        rectangle.beginFill(0xCCCCCC, 0);
        rectangle.lineStyle(3, 0x4286f4, 1);
        rectangle.drawRect(0, 0, GRID_WIDTH, GRID_HEIGHT);
        rectangle.endFill();
        app.stage.addChild(rectangle);
      }
      rectangle.x = selected_pokemon.x - 2;
      rectangle.y = selected_pokemon.y - 5;
      selected_pokemon.alpha = 0.5;
      selected_id = selected_pokemon.texture.textureCacheIds[0];
      selected_pos = findPos(selected_pokemon.x, selected_pokemon.y);
    }

    function findPos(xcor, ycor) {
      for (var i=0; i < GRID_ROW_COUNT; i++) {
        for (var j=0; j < GRID_COL_COUNT; j++) {
          if (grid_matrix[i][j].xcor === xcor
            && grid_matrix[i][j].ycor === ycor){
              return [i, j];
            }
        }
      }
    }

    function canBeErased(first_pos, second_pos) {
      if (first_pos[0] === second_pos[0]
        && first_pos[1] === second_pos[1]
      ) {
        // same pos
        return false;
      }
      if (checkHorizontal(first_pos, second_pos)){
        return true;
      }
      if (checkVertical(first_pos, second_pos)){
        return true;
      }
      if (checkTurnOnce(first_pos, second_pos)){
        return true;
      }
      if (checkMaxTurnTwice(first_pos, second_pos)){
        return true;
      };
      return false;
    }

    function checkHorizontal(first_pos, second_pos) {
      if (first_pos[0] === second_pos[0]
        && first_pos[1] === second_pos[1]
      ) {
        // same pos
        return false;
      }
      if (first_pos[0] === second_pos[0]){
        var start = Math.min(first_pos[1], second_pos[1]);
        var end = Math.max(first_pos[1], second_pos[1])
        for (var j=start+1; j < end; j++){
          if (grid_matrix[first_pos[0]][j].has_pokemon){
            return false;
          }
        }
        return true;
      }
      return false;
    }

    function checkVertical(first_pos, second_pos) {
      if (first_pos[0] === second_pos[0]
        && first_pos[1] === second_pos[1]
      ) {
        // same pos
        return false;
      }
      if (first_pos[1] === second_pos[1]){
        var start = Math.min(first_pos[0], second_pos[0]);
        var end = Math.max(first_pos[0], second_pos[0])
        for (var i=start+1; i < end; i++){
          if (grid_matrix[i][first_pos[1]].has_pokemon){
            return false;
          }
        }
        return true;
      }
      return false;
    }

    function checkTurnOnce(first_pos, second_pos) {
      var first_pos_turn = false;
      if (!grid_matrix[first_pos[0]][second_pos[1]].has_pokemon){
        first_pos_turn = checkHorizontal(
          first_pos,
          [
            first_pos[0],
            second_pos[1]
          ]
        )
        && checkVertical(
          [
            first_pos[0],
            second_pos[1]
          ],
          second_pos
        );
      }

      var second_pos_turn = false;
      if (!grid_matrix[second_pos[0]][first_pos[1]].has_pokemon){
        second_pos_turn = checkHorizontal(
          [
            second_pos[0],
            first_pos[1]
          ],
          second_pos
        )
        && checkVertical(
          first_pos,
          [
            second_pos[0],
            first_pos[1]
          ]
        );
      }
      if (first_pos_turn) {
        second_turn_grid = grid_matrix[first_pos[0]][second_pos[1]];
      }
      if (second_pos_turn) {
        second_turn_grid = grid_matrix[second_pos[0]][first_pos[1]];
      }
      return first_pos_turn || second_pos_turn;
    }

    function checkMaxTurnTwice(first_pos, second_pos) {
      var cur_pos;
      cur_pos = [first_pos[0]-1, first_pos[1]];
      while (cur_pos[0] >= 0
        && !grid_matrix[cur_pos[0]][cur_pos[1]].has_pokemon
      ) {
        if (checkTurnOnce(cur_pos, second_pos)){
          first_turn_grid = grid_matrix[cur_pos[0]][cur_pos[1]];
          return true;
        }
        cur_pos[0] -= 1;
      }

      cur_pos = [first_pos[0]+1, first_pos[1]];
      while (cur_pos[0] < GRID_ROW_COUNT
        && !grid_matrix[cur_pos[0]][cur_pos[1]].has_pokemon
      ) {
        if (checkTurnOnce(cur_pos, second_pos)){
          first_turn_grid = grid_matrix[cur_pos[0]][cur_pos[1]];
          return true;
        }
        cur_pos[0] += 1;
      }

      cur_pos = [first_pos[0], first_pos[1]-1];
      while (cur_pos[1] >= 0
        && !grid_matrix[cur_pos[0]][cur_pos[1]].has_pokemon
      ) {
        if (checkTurnOnce(cur_pos, second_pos)){
          first_turn_grid = grid_matrix[cur_pos[0]][cur_pos[1]];
          return true;
        }
        cur_pos[1] -= 1;
      }

      cur_pos = [first_pos[0], first_pos[1]+1];
      while (cur_pos[1] < GRID_COL_COUNT
        && !grid_matrix[cur_pos[0]][cur_pos[1]].has_pokemon
      ) {
        if (checkTurnOnce(cur_pos, second_pos)){
          first_turn_grid = grid_matrix[cur_pos[0]][cur_pos[1]];
          return true;
        }
        cur_pos[1] += 1;
      }

      return false;
    }

  </script>
</body>
</html>
