<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Crushing</title>
</head>
  <script src="pixijs/pixi.min.js"></script>
<body>
  <script type="text/javascript">
    var CANVAS_WIDTH = 1200;
    var CANVAS_HEIGHT = 650;
    var LEFT_MARGIN = 100;
    var TOP_MARGIN = 30;
    var GRID_WIDTH = 50;
    var GRID_HEIGHT = 65;
    var ROW_COUNT = CANVAS_HEIGHT / GRID_HEIGHT;
    var COL_COUNT = CANVAS_WIDTH / GRID_WIDTH;
    var SPECIES_OF_POKEMON = 20;

    var app = new PIXI.Application(window.innerWidth, window.innerHeight, { transparent: true });
    document.body.appendChild(app.view);

    var grid_matrix;

    PIXI.loader
      .add("tilesets/pokemons_0.json")
      .load(setup);

    function setup() {
      // get all the pokemons
      var pokemonTexture;
      var pokemon;
      var pokemons = [];
      for (var t in PIXI.utils.TextureCache){
        if (t.startsWith("300px")){
          pokemonTexture = PIXI.utils.TextureCache[t];
          pokemons.push(pokemonTexture);
        }
      }

      var i = 0;
      var j = 0;
      var rand_idx;
      var is_second = false;
      // init matrix
      var pokemon_matrix = new Array(ROW_COUNT);
      for (i = 0; i < ROW_COUNT; i++) {
        pokemon_matrix[i] = new Array(COL_COUNT);
      }

      for (i = 0; i < ROW_COUNT; i++) {
        for (j = 0; j < COL_COUNT; j++) {
          if (!is_second) {
            rand_idx = Math.floor(
              Math.random() *
              Math.max(pokemons.length, SPECIES_OF_POKEMON)
            );
          }
          is_second = !is_second;
          pokemon = new PIXI.Sprite(pokemons[rand_idx]);
          pokemon_matrix[i][j] = pokemon;
        }
      }

      // shuffle the matrix, change if a better way is found
      for (i = 0; i < ROW_COUNT; i++) {
        pokemon_matrix[i].sort(function() { return 0.5 - Math.random() });
      }
      pokemon_matrix.sort(function() { return 0.5 - Math.random() });

      // init the grid system
      var grid_x = LEFT_MARGIN;
      var grid_y = TOP_MARGIN;
      var background = new PIXI.Graphics();
      background.beginFill(0xCCCCCC);
      background.lineStyle(2, 0xCCCCCC, 1);
      background.drawRect(LEFT_MARGIN, TOP_MARGIN, CANVAS_WIDTH, CANVAS_HEIGHT);
      background.endFill();

      // init matrix
      grid_matrix = new Array(ROW_COUNT);
      for (i = 0; i < ROW_COUNT; i++) {
        grid_matrix[i] = new Array(COL_COUNT);
      }

      for (i = 0; i < ROW_COUNT; i++) {
        for (j = 0; j < COL_COUNT; j++) {
          var grid = new PIXI.Graphics();
          grid.buttonMode = true;
          grid.beginFill(0xFFFFFF);
          grid.lineStyle(2, 0xcbcfd6, 1);
          grid_x = LEFT_MARGIN + j * GRID_WIDTH;
          grid_y = TOP_MARGIN + i * GRID_HEIGHT;
          grid.drawRect(grid_x, grid_y, GRID_WIDTH, GRID_HEIGHT);
          grid.endFill();

          pokemon = pokemon_matrix[i][j];
          pokemon.scale.set(0.16);
          pokemon.x = grid_x + 2;
          pokemon.y = grid_y + 5;
          grid.addChild(pokemon);
          grid_matrix[i][j] = {
            "xcor": pokemon.x,
            "ycor": pokemon.y,
            "has_pokemon": true
          };

          grid.interactive = true;
          grid.buttonMode = true;
          grid.on('pointerdown', gridClick);

          background.addChild(grid);
        }
      }

      app.stage.addChild(background);
    }

    var rectangle;
    var selected_pokemon;
    var cur_id;
    var selected_pos;
    var cur_pos;
    function gridClick() {
      if (selected_pokemon !== undefined) {
        selected_pokemon.alpha = 1;
        cur_pos = findPos(
          this.children[0].x, this.children[0].y
        );
        if (cur_id === this.children[0].texture.textureCacheIds[0]
          && canBeErased(selected_pos, cur_pos)
        ) {
          var line = new PIXI.Graphics();
          line.lineStyle(4, 0x0a3d91, 1);
          line.moveTo(
            selected_pokemon.x + GRID_WIDTH / 2 - 2,
            selected_pokemon.y + GRID_HEIGHT / 2 -5
          );
          line.lineTo(
            this.children[0].x + GRID_WIDTH / 2 - 2,
            this.children[0].y + GRID_HEIGHT / 2 - 5
          );
          app.stage.addChild(line);
          var cur_grid = this;
          setTimeout(function(){
            grid_matrix[selected_pos[0]][selected_pos[1]].has_pokemon = false;
            grid_matrix[cur_pos[0]][cur_pos[1]].has_pokemon = false;
            selected_pokemon.parent.destroy();
            cur_grid.destroy();
            rectangle.destroy();
            rectangle = undefined;
            cur_id = undefined;
            selected_pokemon = undefined;
            selected_pos = undefined;
            line.destroy();
          }, 200);
          return;
        }
      }
      selected_pokemon = this.children[0];

      if (rectangle === undefined) {
        rectangle = new PIXI.Graphics();
        rectangle.beginFill(0xCCCCCC, 0);
        rectangle.lineStyle(3, 0x4286f4, 1);
        rectangle.drawRect(0, 0, GRID_WIDTH, GRID_HEIGHT);
        rectangle.endFill();
        app.stage.addChild(rectangle);
      }
      rectangle.x = selected_pokemon.x - 2;
      rectangle.y = selected_pokemon.y - 5;
      selected_pokemon.alpha = 0.5;
      cur_id = selected_pokemon.texture.textureCacheIds[0];
      selected_pos = findPos(selected_pokemon.x, selected_pokemon.y);
    }

    function findPos(xcor, ycor) {
      for (var i=0; i < ROW_COUNT; i++) {
        for (var j=0; j < COL_COUNT; j++) {
          if (grid_matrix[i][j].xcor === xcor
            && grid_matrix[i][j].ycor === ycor){
              return [i, j];
            }
        }
      }
    }

    function canBeErased(first_pos, second_pos) {
      console.log(first_pos);
      console.log(second_pos);
      return true;
    }

  </script>
</body>
</html>
